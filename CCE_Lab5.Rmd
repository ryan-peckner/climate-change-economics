---
title: "CCE_Lab5"
author: "Ryan Peckner"
date: "7/27/2021"
output: html_document
---

We'll introduce income elasticity as another parameter to the damages function.

```{r}

source("CCE_Lab1_MainFunctions.R")
source("CCE_Lab3_MainFunctions.R")
forcings4 = read.csv("CCE_Lab4_Outputs.csv",stringsAsFactors = FALSE)
Psi = 0.003
Y_0 = forcings4$gross.output.bau[1]

DamagesWithIncomeElasticity = function(t,temp_increase,gross_income,income_elasticity) {
  income_elasticity_term = (gross_income[t]/Y_0)^income_elasticity
  return(psi*(temp_increase[t]^2)*income_elasticity_term)
}


```

Let's break down this formula a bit. As per our previous model, the gross output is given by
$$Y_{t}^{G} = A_{t}K_{t}^{\alpha}P_{t}^{1-\alpha}.$$
Since we are now incorporating damages, there is a new equation of motion for the capital stock $K_{t}$:
$$K_{t} = (1-\delta)K_{t-1} + s(1-\Lambda_{t-1} - D_{t-1})A_{t-1}K_{t-1}^{\alpha}P_{t-1}^{1-\alpha}.$$
Plugging this expression into the formula for $Y_{t}^{G}$ yields
$$Y_{t}^{G} = A_{t}\left[(1-\delta)K_{t-1} + s(1-\Lambda_{t-1} - D_{t-1})A_{t-1}K_{t-1}^{\alpha}P_{t-1}^{1-\alpha}\right]^{\alpha}P_{t}^{1-\alpha}.$$

Now, the new expression for the damages with the income elasticity term is
$$D_{t} = \Psi T_{t}^{2}\left(\frac{Y_{t}^{G}}{Y_{0}}\right)^{\epsilon}.$$

Plugging this into the above expression for $Y_{t}^{G}$ yields 
$$Y_{t}^{G} = A_{t}\left[(1-\delta)K_{t-1} + s\left\{1-\Lambda_{t-1} - \Psi T_{t-1}^{2}\left(\frac{Y_{t-1}^{G}}{Y_{0}}\right)^{\epsilon}\right\}A_{t-1}K_{t-1}^{\alpha}P_{t-1}^{1-\alpha}\right]^{\alpha}P_{t}^{1-\alpha}.$$ 
Finally, we can write $K_{t} = (Y_{t}^{G}/(A_{t}P_{t}^{1-\alpha}))^{1/\alpha}$ to yield
$$Y_{t}^{G} = A_{t}\left[(1-\delta)\left(\frac{Y_{t-1}^{G}}{A_{t-1}P_{t-1}^{1-\alpha}}\right)^{1/\alpha} + s\left\{1-\Lambda_{t-1} - \Psi T_{t-1}^{2}\left(\frac{Y_{t-1}^{G}}{Y_{0}}\right)^{\epsilon}\right\}A_{t-1}\left(\frac{Y_{t-1}^{G}}{A_{t-1}P_{t-1}^{1-\alpha}}\right)P_{t-1}^{1-\alpha}\right]^{\alpha}P_{t}^{1-\alpha},$$
which simplifies to 
$$Y_{t}^{G} = A_{t}\left[(1-\delta)\left(\frac{Y_{t-1}^{G}}{A_{t-1}P_{t-1}^{1-\alpha}}\right)^{1/\alpha} + s\left\{1-\Lambda_{t-1} - \Psi T_{t-1}^{2}\left(\frac{Y_{t-1}^{G}}{Y_{0}}\right)^{\epsilon}\right\}Y_{t-1}^{G}\right]^{\alpha}P_{t}^{1-\alpha}.$$

This gives a new, albeit monstrous, recursive expression for gross output that allows us to couple GDP, temperature, abatement costs, and income elasticity:

```{r}

delta = 0.1
alpha1 = 0.3
s = 0.22

forcings4$population = forcings2$population
forcings4$population.millions = 1e-6*forcings4$population

GrossOutputWithIncomeElasticity = function(t,temp_increase,abatement_cost,income_elasticity) {
  if (t == 1) {
    return(forcings5$gross.output.bau[1])
  } else {
    Y_t_1 = GrossOutputWithIncomeElasticity(t-1,temp_increase,abatement_cost,income_elasticity)
    first_term = (1-delta)*(Y_t_1/(forcings4$total.factor.productivity[t-1]*(forcings4$population.millions[t-1]^(1-alpha1))))^(1/alpha1)
    second_term  = s*(1 - abatement_cost[t-1] - Psi*(temp_increase^2)*((Y_t_1/Y_0)^(income_elasticity)))*Y_t_1
    return(forcings4$total.factor.productivity[t]*((first_term + second_term)^(alpha1))*(forcings4$population.millions[t]^(1-alpha1)))
  }
}


```

Instead of computing this for all time points at once, we will compute it iteratively for each time step to allow the temperature to evolve along with the gross output, at first assuming no emissions reduction (so abatement cost is 0):

```{r,cache=TRUE}

forcings5 = forcings4

forcings5$gross.output_0elasticity = numeric(nrow(forcings5))
forcings5$gross.output_0elasticity[1] = forcings4$gross.output.bau[1]
forcings5$temp.increase_0elasticity = numeric(nrow(forcings5))
forcings5$temp.increase_0elasticity[1] = forcings2$temp.increase.bau[1]

for (t in 2:nrow(forcings5)) {
  forcings5$gross.output_0elasticity[t] = 
    GrossOutputWithIncomeElasticity(t,forcings5$temp.increase_0elasticity[t-1],
                                    abatement_cost =  rep(0,nrow(forcings5)),
                                    income_elasticity = 0)
  forcings5$temp.increase_0elasticity[t] = 
          GlobalAvgTempIncrease_FromEmissions(t,
                                    emissions = 
                                     rep(KayaEmissionsFromGDP(t,population = 1e-6*forcings2$population,
                                                          output = forcings5$gross.output_0elasticity,
                                                          energy_intensity = forcings2$energy.intensity,
                                                          emission_intensity = forcings2$carbon.intensity) +
                                        forcings2$land.use.emissions[t],nrow(forcings5)))
}


```
Unfortunately, this is returning numbers that clearly don't make sense:
```{r}

head(forcings5)

```

So, there is a problem somewhere in the above implementation.